{"ast":null,"code":"// Advanced breath pattern analysis utilities\n\nexport function analyzeBreathPattern(history) {\n  if (history.length < 10) {\n    return {\n      trend: \"neutral\",\n      avgAmplitude: 0,\n      frequency: 0,\n      stability: 0,\n      cycles: 0\n    };\n  }\n  const amplitudes = history.map(entry => entry.amplitude);\n  const frequencies = history.map(entry => entry.frequency);\n  const timestamps = history.map(entry => entry.timestamp);\n  return {\n    trend: analyzeTrend(amplitudes),\n    avgAmplitude: calculateAverage(amplitudes),\n    frequency: calculateAverage(frequencies),\n    stability: calculateStability(amplitudes),\n    cycles: detectBreathCycles(amplitudes, timestamps),\n    peakDetection: findPeaks(amplitudes),\n    rhythmAnalysis: analyzeRhythm(amplitudes, timestamps)\n  };\n}\nfunction analyzeTrend(amplitudes) {\n  if (amplitudes.length < 5) return \"neutral\";\n  const recent = amplitudes.slice(-5);\n  const older = amplitudes.slice(-10, -5);\n  const recentAvg = calculateAverage(recent);\n  const olderAvg = calculateAverage(older);\n  const threshold = 0.02;\n  if (recentAvg > olderAvg + threshold) return \"increasing\";\n  if (recentAvg < olderAvg - threshold) return \"decreasing\";\n  return \"stable\";\n}\nfunction calculateAverage(array) {\n  return array.length > 0 ? array.reduce((sum, val) => sum + val, 0) / array.length : 0;\n}\nfunction calculateStability(amplitudes) {\n  if (amplitudes.length < 10) return 0;\n  const mean = calculateAverage(amplitudes);\n  const variance = amplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / amplitudes.length;\n  const stdDev = Math.sqrt(variance);\n\n  // Return stability as 1 - normalized standard deviation\n  return Math.max(0, 1 - stdDev / (mean + 0.001));\n}\nfunction detectBreathCycles(amplitudes, timestamps) {\n  if (amplitudes.length < 20) return 0;\n  const peaks = findPeaks(amplitudes);\n  const valleys = findValleys(amplitudes);\n\n  // A breath cycle is peak -> valley -> peak\n  const cycles = Math.min(peaks.length - 1, valleys.length);\n\n  // Calculate average cycle duration\n  if (peaks.length > 1) {\n    const cycleDurations = [];\n    for (let i = 1; i < peaks.length; i++) {\n      const duration = timestamps[peaks[i]] - timestamps[peaks[i - 1]];\n      cycleDurations.push(duration);\n    }\n    const avgCycleDuration = calculateAverage(cycleDurations);\n    // Normal breathing cycle is 3-6 seconds\n    const normalizedDuration = Math.max(0, 1 - Math.abs(avgCycleDuration - 4000) / 2000);\n    return {\n      count: cycles,\n      avgDuration: avgCycleDuration,\n      quality: normalizedDuration\n    };\n  }\n  return {\n    count: 0,\n    avgDuration: 0,\n    quality: 0\n  };\n}\nfunction findPeaks(amplitudes) {\n  const peaks = [];\n  const minPeakHeight = calculateAverage(amplitudes) * 0.8;\n  const minDistance = 5; // Minimum distance between peaks\n\n  for (let i = 1; i < amplitudes.length - 1; i++) {\n    if (amplitudes[i] > amplitudes[i - 1] && amplitudes[i] > amplitudes[i + 1] && amplitudes[i] > minPeakHeight) {\n      // Check minimum distance from last peak\n      if (peaks.length === 0 || i - peaks[peaks.length - 1] >= minDistance) {\n        peaks.push(i);\n      }\n    }\n  }\n  return peaks;\n}\nfunction findValleys(amplitudes) {\n  const valleys = [];\n  const maxValleyHeight = calculateAverage(amplitudes) * 0.5;\n  const minDistance = 5;\n  for (let i = 1; i < amplitudes.length - 1; i++) {\n    if (amplitudes[i] < amplitudes[i - 1] && amplitudes[i] < amplitudes[i + 1] && amplitudes[i] < maxValleyHeight) {\n      if (valleys.length === 0 || i - valleys[valleys.length - 1] >= minDistance) {\n        valleys.push(i);\n      }\n    }\n  }\n  return valleys;\n}\nfunction analyzeRhythm(amplitudes, timestamps) {\n  const peaks = findPeaks(amplitudes);\n  if (peaks.length < 3) {\n    return {\n      regularity: 0,\n      tempo: 0,\n      coherence: 0\n    };\n  }\n\n  // Calculate intervals between peaks\n  const intervals = [];\n  for (let i = 1; i < peaks.length; i++) {\n    intervals.push(timestamps[peaks[i]] - timestamps[peaks[i - 1]]);\n  }\n  const avgInterval = calculateAverage(intervals);\n  const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length;\n  const stdDev = Math.sqrt(variance);\n\n  // Regularity: how consistent the intervals are\n  const regularity = Math.max(0, 1 - stdDev / avgInterval);\n\n  // Tempo: breaths per minute\n  const tempo = 60000 / avgInterval; // Convert ms to breaths per minute\n\n  // Coherence: combination of regularity and optimal tempo (12-20 bpm is ideal)\n  const optimalTempo = tempo >= 12 && tempo <= 20 ? 1 : Math.max(0, 1 - Math.abs(tempo - 16) / 10);\n  const coherence = (regularity + optimalTempo) / 2;\n  return {\n    regularity,\n    tempo,\n    coherence,\n    intervals,\n    avgInterval\n  };\n}\n\n// Advanced breath state detection\nexport function detectBreathState(pattern) {\n  const {\n    rhythmAnalysis,\n    stability,\n    avgAmplitude\n  } = pattern;\n  if (rhythmAnalysis.coherence > 0.8 && stability > 0.7) {\n    return \"deep_meditation\";\n  } else if (rhythmAnalysis.coherence > 0.6 && rhythmAnalysis.tempo <= 15) {\n    return \"relaxed\";\n  } else if (rhythmAnalysis.tempo > 20 || stability < 0.4) {\n    return \"active\";\n  } else if (avgAmplitude < 0.1) {\n    return \"shallow\";\n  } else {\n    return \"normal\";\n  }\n}\n\n// Consciousness mapping functions\nexport function mapBreathToConsciousness(breathState, pattern) {\n  const baseConsciousness = {\n    deep_meditation: 0.9,\n    relaxed: 0.7,\n    normal: 0.5,\n    active: 0.3,\n    shallow: 0.2\n  };\n  const base = baseConsciousness[breathState] || 0.5;\n  const coherenceBonus = pattern.rhythmAnalysis.coherence * 0.2;\n  const stabilityBonus = pattern.stability * 0.1;\n  return Math.min(1, base + coherenceBonus + stabilityBonus);\n}\nexport function mapBreathToComplexity(breathDepth, stability, cycles) {\n  const depthFactor = breathDepth * 0.4;\n  const stabilityFactor = stability * 0.3;\n  const cycleFactor = cycles.quality * 0.3;\n  return Math.min(2, depthFactor + stabilityFactor + cycleFactor);\n}","map":{"version":3,"names":["analyzeBreathPattern","history","length","trend","avgAmplitude","frequency","stability","cycles","amplitudes","map","entry","amplitude","frequencies","timestamps","timestamp","analyzeTrend","calculateAverage","calculateStability","detectBreathCycles","peakDetection","findPeaks","rhythmAnalysis","analyzeRhythm","recent","slice","older","recentAvg","olderAvg","threshold","array","reduce","sum","val","mean","variance","Math","pow","stdDev","sqrt","max","peaks","valleys","findValleys","min","cycleDurations","i","duration","push","avgCycleDuration","normalizedDuration","abs","count","avgDuration","quality","minPeakHeight","minDistance","maxValleyHeight","regularity","tempo","coherence","intervals","avgInterval","interval","optimalTempo","detectBreathState","pattern","mapBreathToConsciousness","breathState","baseConsciousness","deep_meditation","relaxed","normal","active","shallow","base","coherenceBonus","stabilityBonus","mapBreathToComplexity","breathDepth","depthFactor","stabilityFactor","cycleFactor"],"sources":["/home/ahiya/Ahiya/full_projects/breathing-cosmos/src/utils/breathAnalysis.js"],"sourcesContent":["// Advanced breath pattern analysis utilities\n\nexport function analyzeBreathPattern(history) {\n  if (history.length < 10) {\n    return {\n      trend: \"neutral\",\n      avgAmplitude: 0,\n      frequency: 0,\n      stability: 0,\n      cycles: 0,\n    };\n  }\n\n  const amplitudes = history.map((entry) => entry.amplitude);\n  const frequencies = history.map((entry) => entry.frequency);\n  const timestamps = history.map((entry) => entry.timestamp);\n\n  return {\n    trend: analyzeTrend(amplitudes),\n    avgAmplitude: calculateAverage(amplitudes),\n    frequency: calculateAverage(frequencies),\n    stability: calculateStability(amplitudes),\n    cycles: detectBreathCycles(amplitudes, timestamps),\n    peakDetection: findPeaks(amplitudes),\n    rhythmAnalysis: analyzeRhythm(amplitudes, timestamps),\n  };\n}\n\nfunction analyzeTrend(amplitudes) {\n  if (amplitudes.length < 5) return \"neutral\";\n\n  const recent = amplitudes.slice(-5);\n  const older = amplitudes.slice(-10, -5);\n\n  const recentAvg = calculateAverage(recent);\n  const olderAvg = calculateAverage(older);\n\n  const threshold = 0.02;\n\n  if (recentAvg > olderAvg + threshold) return \"increasing\";\n  if (recentAvg < olderAvg - threshold) return \"decreasing\";\n  return \"stable\";\n}\n\nfunction calculateAverage(array) {\n  return array.length > 0\n    ? array.reduce((sum, val) => sum + val, 0) / array.length\n    : 0;\n}\n\nfunction calculateStability(amplitudes) {\n  if (amplitudes.length < 10) return 0;\n\n  const mean = calculateAverage(amplitudes);\n  const variance =\n    amplitudes.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) /\n    amplitudes.length;\n  const stdDev = Math.sqrt(variance);\n\n  // Return stability as 1 - normalized standard deviation\n  return Math.max(0, 1 - stdDev / (mean + 0.001));\n}\n\nfunction detectBreathCycles(amplitudes, timestamps) {\n  if (amplitudes.length < 20) return 0;\n\n  const peaks = findPeaks(amplitudes);\n  const valleys = findValleys(amplitudes);\n\n  // A breath cycle is peak -> valley -> peak\n  const cycles = Math.min(peaks.length - 1, valleys.length);\n\n  // Calculate average cycle duration\n  if (peaks.length > 1) {\n    const cycleDurations = [];\n    for (let i = 1; i < peaks.length; i++) {\n      const duration = timestamps[peaks[i]] - timestamps[peaks[i - 1]];\n      cycleDurations.push(duration);\n    }\n\n    const avgCycleDuration = calculateAverage(cycleDurations);\n    // Normal breathing cycle is 3-6 seconds\n    const normalizedDuration = Math.max(\n      0,\n      1 - Math.abs(avgCycleDuration - 4000) / 2000\n    );\n\n    return {\n      count: cycles,\n      avgDuration: avgCycleDuration,\n      quality: normalizedDuration,\n    };\n  }\n\n  return { count: 0, avgDuration: 0, quality: 0 };\n}\n\nfunction findPeaks(amplitudes) {\n  const peaks = [];\n  const minPeakHeight = calculateAverage(amplitudes) * 0.8;\n  const minDistance = 5; // Minimum distance between peaks\n\n  for (let i = 1; i < amplitudes.length - 1; i++) {\n    if (\n      amplitudes[i] > amplitudes[i - 1] &&\n      amplitudes[i] > amplitudes[i + 1] &&\n      amplitudes[i] > minPeakHeight\n    ) {\n      // Check minimum distance from last peak\n      if (peaks.length === 0 || i - peaks[peaks.length - 1] >= minDistance) {\n        peaks.push(i);\n      }\n    }\n  }\n\n  return peaks;\n}\n\nfunction findValleys(amplitudes) {\n  const valleys = [];\n  const maxValleyHeight = calculateAverage(amplitudes) * 0.5;\n  const minDistance = 5;\n\n  for (let i = 1; i < amplitudes.length - 1; i++) {\n    if (\n      amplitudes[i] < amplitudes[i - 1] &&\n      amplitudes[i] < amplitudes[i + 1] &&\n      amplitudes[i] < maxValleyHeight\n    ) {\n      if (\n        valleys.length === 0 ||\n        i - valleys[valleys.length - 1] >= minDistance\n      ) {\n        valleys.push(i);\n      }\n    }\n  }\n\n  return valleys;\n}\n\nfunction analyzeRhythm(amplitudes, timestamps) {\n  const peaks = findPeaks(amplitudes);\n\n  if (peaks.length < 3) {\n    return { regularity: 0, tempo: 0, coherence: 0 };\n  }\n\n  // Calculate intervals between peaks\n  const intervals = [];\n  for (let i = 1; i < peaks.length; i++) {\n    intervals.push(timestamps[peaks[i]] - timestamps[peaks[i - 1]]);\n  }\n\n  const avgInterval = calculateAverage(intervals);\n  const variance =\n    intervals.reduce(\n      (sum, interval) => sum + Math.pow(interval - avgInterval, 2),\n      0\n    ) / intervals.length;\n  const stdDev = Math.sqrt(variance);\n\n  // Regularity: how consistent the intervals are\n  const regularity = Math.max(0, 1 - stdDev / avgInterval);\n\n  // Tempo: breaths per minute\n  const tempo = 60000 / avgInterval; // Convert ms to breaths per minute\n\n  // Coherence: combination of regularity and optimal tempo (12-20 bpm is ideal)\n  const optimalTempo =\n    tempo >= 12 && tempo <= 20 ? 1 : Math.max(0, 1 - Math.abs(tempo - 16) / 10);\n  const coherence = (regularity + optimalTempo) / 2;\n\n  return {\n    regularity,\n    tempo,\n    coherence,\n    intervals,\n    avgInterval,\n  };\n}\n\n// Advanced breath state detection\nexport function detectBreathState(pattern) {\n  const { rhythmAnalysis, stability, avgAmplitude } = pattern;\n\n  if (rhythmAnalysis.coherence > 0.8 && stability > 0.7) {\n    return \"deep_meditation\";\n  } else if (rhythmAnalysis.coherence > 0.6 && rhythmAnalysis.tempo <= 15) {\n    return \"relaxed\";\n  } else if (rhythmAnalysis.tempo > 20 || stability < 0.4) {\n    return \"active\";\n  } else if (avgAmplitude < 0.1) {\n    return \"shallow\";\n  } else {\n    return \"normal\";\n  }\n}\n\n// Consciousness mapping functions\nexport function mapBreathToConsciousness(breathState, pattern) {\n  const baseConsciousness = {\n    deep_meditation: 0.9,\n    relaxed: 0.7,\n    normal: 0.5,\n    active: 0.3,\n    shallow: 0.2,\n  };\n\n  const base = baseConsciousness[breathState] || 0.5;\n  const coherenceBonus = pattern.rhythmAnalysis.coherence * 0.2;\n  const stabilityBonus = pattern.stability * 0.1;\n\n  return Math.min(1, base + coherenceBonus + stabilityBonus);\n}\n\nexport function mapBreathToComplexity(breathDepth, stability, cycles) {\n  const depthFactor = breathDepth * 0.4;\n  const stabilityFactor = stability * 0.3;\n  const cycleFactor = cycles.quality * 0.3;\n\n  return Math.min(2, depthFactor + stabilityFactor + cycleFactor);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}