{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useRef } from \"react\";\nimport { analyzeBreathPattern } from \"../utils/breathAnalysis\";\nfunction useBreathDetection(microphoneStream) {\n  _s();\n  const [breathData, setBreathData] = useState(null);\n  const audioContextRef = useRef(null);\n  const analyzerRef = useRef(null);\n  const sourceRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const breathHistoryRef = useRef([]);\n  const lastPhaseRef = useRef(\"neutral\");\n  const phaseTimerRef = useRef(0);\n  useEffect(() => {\n    if (!microphoneStream) return;\n    const setupAudioAnalysis = async () => {\n      try {\n        // Create audio context\n        audioContextRef.current = new (window.AudioContext || window.webkitAudioContext)();\n\n        // Create analyzer node\n        analyzerRef.current = audioContextRef.current.createAnalyser();\n        analyzerRef.current.fftSize = 2048;\n        analyzerRef.current.smoothingTimeConstant = 0.3;\n\n        // Create source from microphone stream\n        sourceRef.current = audioContextRef.current.createMediaStreamSource(microphoneStream);\n        sourceRef.current.connect(analyzerRef.current);\n\n        // Start analysis loop\n        startBreathAnalysis();\n      } catch (error) {\n        console.error(\"Error setting up audio analysis:\", error);\n      }\n    };\n    setupAudioAnalysis();\n    return () => {\n      cleanup();\n    };\n  }, [microphoneStream]);\n  const startBreathAnalysis = () => {\n    const bufferLength = analyzerRef.current.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n    const analyze = () => {\n      if (!analyzerRef.current) return;\n      analyzerRef.current.getByteFrequencyData(dataArray);\n\n      // Focus on breathing frequency range (0.1 - 2 Hz)\n      // This translates to lower frequency bins in our FFT\n      const breathingBins = dataArray.slice(1, 20); // Approximate breathing range\n\n      // Calculate amplitude (breath volume)\n      const amplitude = breathingBins.reduce((sum, val) => sum + val, 0) / breathingBins.length / 255;\n\n      // Calculate dominant frequency in breathing range\n      const maxBin = breathingBins.reduce((maxIdx, val, idx) => val > breathingBins[maxIdx] ? idx : maxIdx, 0);\n      const dominantFreq = maxBin * (audioContextRef.current.sampleRate / analyzerRef.current.fftSize);\n\n      // Add to history for pattern analysis\n      const timestamp = Date.now();\n      breathHistoryRef.current.push({\n        amplitude,\n        frequency: dominantFreq,\n        timestamp\n      });\n\n      // Keep only recent history (last 10 seconds)\n      breathHistoryRef.current = breathHistoryRef.current.filter(entry => timestamp - entry.timestamp < 10000);\n\n      // Analyze breathing pattern\n      const pattern = analyzeBreathPattern(breathHistoryRef.current);\n\n      // Determine breath phase\n      const breathPhase = determineBreathPhase(amplitude, pattern);\n\n      // Calculate breath metrics\n      const breathDepth = Math.min(1, amplitude * 2); // Normalize breath depth\n      const breathRhythm = calculateRhythm(breathHistoryRef.current);\n      const coherence = calculateCoherence(breathHistoryRef.current);\n      setBreathData({\n        amplitude,\n        frequency: dominantFreq,\n        breathPhase,\n        breathDepth,\n        breathRhythm,\n        coherence,\n        rawData: Array.from(breathingBins)\n      });\n      animationFrameRef.current = requestAnimationFrame(analyze);\n    };\n    analyze();\n  };\n  const determineBreathPhase = (amplitude, pattern) => {\n    const threshold = 0.1;\n    const currentTime = Date.now();\n\n    // Detect phase transitions based on amplitude changes\n    if (amplitude > threshold) {\n      if (pattern.trend === \"increasing\" && amplitude > pattern.avgAmplitude * 1.2) {\n        if (lastPhaseRef.current !== \"inhale\") {\n          lastPhaseRef.current = \"inhale\";\n          phaseTimerRef.current = currentTime;\n        }\n        return \"inhale\";\n      } else if (pattern.trend === \"decreasing\" && amplitude > pattern.avgAmplitude * 0.8) {\n        if (lastPhaseRef.current !== \"exhale\") {\n          lastPhaseRef.current = \"exhale\";\n          phaseTimerRef.current = currentTime;\n        }\n        return \"exhale\";\n      }\n    } else {\n      // Low amplitude - likely a pause between breaths\n      if (currentTime - phaseTimerRef.current > 500) {\n        // 500ms threshold\n        lastPhaseRef.current = \"pause\";\n        return \"pause\";\n      }\n    }\n    return lastPhaseRef.current || \"neutral\";\n  };\n  const calculateRhythm = history => {\n    if (history.length < 20) return 0;\n\n    // Calculate rhythm consistency over time\n    const intervals = [];\n    for (let i = 1; i < history.length; i++) {\n      intervals.push(history[i].timestamp - history[i - 1].timestamp);\n    }\n    const avgInterval = intervals.reduce((sum, val) => sum + val, 0) / intervals.length;\n    const variance = intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) / intervals.length;\n    const stdDev = Math.sqrt(variance);\n\n    // Lower standard deviation means more rhythmic breathing\n    return Math.max(0, 1 - stdDev / avgInterval);\n  };\n  const calculateCoherence = history => {\n    if (history.length < 30) return 0;\n\n    // Heart Rate Variability-inspired coherence calculation\n    const amplitudes = history.map(entry => entry.amplitude);\n    const mean = amplitudes.reduce((sum, val) => sum + val, 0) / amplitudes.length;\n\n    // Calculate how smoothly amplitude changes over time\n    let coherenceScore = 0;\n    for (let i = 1; i < amplitudes.length; i++) {\n      const change = Math.abs(amplitudes[i] - amplitudes[i - 1]);\n      coherenceScore += Math.exp(-change * 10); // Reward smooth changes\n    }\n    return Math.min(1, coherenceScore / amplitudes.length);\n  };\n  const cleanup = () => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n    if (sourceRef.current) {\n      sourceRef.current.disconnect();\n    }\n    if (audioContextRef.current && audioContextRef.current.state !== \"closed\") {\n      audioContextRef.current.close();\n    }\n  };\n  return breathData;\n}\n_s(useBreathDetection, \"+3gl+YRwJQQ/dIa4LTLRr9HFz9g=\");\nexport default useBreathDetection;","map":{"version":3,"names":["useState","useEffect","useRef","analyzeBreathPattern","useBreathDetection","microphoneStream","_s","breathData","setBreathData","audioContextRef","analyzerRef","sourceRef","animationFrameRef","breathHistoryRef","lastPhaseRef","phaseTimerRef","setupAudioAnalysis","current","window","AudioContext","webkitAudioContext","createAnalyser","fftSize","smoothingTimeConstant","createMediaStreamSource","connect","startBreathAnalysis","error","console","cleanup","bufferLength","frequencyBinCount","dataArray","Uint8Array","analyze","getByteFrequencyData","breathingBins","slice","amplitude","reduce","sum","val","length","maxBin","maxIdx","idx","dominantFreq","sampleRate","timestamp","Date","now","push","frequency","filter","entry","pattern","breathPhase","determineBreathPhase","breathDepth","Math","min","breathRhythm","calculateRhythm","coherence","calculateCoherence","rawData","Array","from","requestAnimationFrame","threshold","currentTime","trend","avgAmplitude","history","intervals","i","avgInterval","variance","pow","stdDev","sqrt","max","amplitudes","map","mean","coherenceScore","change","abs","exp","cancelAnimationFrame","disconnect","state","close"],"sources":["/home/ahiya/Ahiya/full_projects/breathing-cosmos/src/hooks/useBreathDetection.js"],"sourcesContent":["import { useState, useEffect, useRef } from \"react\";\nimport { analyzeBreathPattern } from \"../utils/breathAnalysis\";\n\nfunction useBreathDetection(microphoneStream) {\n  const [breathData, setBreathData] = useState(null);\n\n  const audioContextRef = useRef(null);\n  const analyzerRef = useRef(null);\n  const sourceRef = useRef(null);\n  const animationFrameRef = useRef(null);\n  const breathHistoryRef = useRef([]);\n  const lastPhaseRef = useRef(\"neutral\");\n  const phaseTimerRef = useRef(0);\n\n  useEffect(() => {\n    if (!microphoneStream) return;\n\n    const setupAudioAnalysis = async () => {\n      try {\n        // Create audio context\n        audioContextRef.current = new (window.AudioContext ||\n          window.webkitAudioContext)();\n\n        // Create analyzer node\n        analyzerRef.current = audioContextRef.current.createAnalyser();\n        analyzerRef.current.fftSize = 2048;\n        analyzerRef.current.smoothingTimeConstant = 0.3;\n\n        // Create source from microphone stream\n        sourceRef.current =\n          audioContextRef.current.createMediaStreamSource(microphoneStream);\n        sourceRef.current.connect(analyzerRef.current);\n\n        // Start analysis loop\n        startBreathAnalysis();\n      } catch (error) {\n        console.error(\"Error setting up audio analysis:\", error);\n      }\n    };\n\n    setupAudioAnalysis();\n\n    return () => {\n      cleanup();\n    };\n  }, [microphoneStream]);\n\n  const startBreathAnalysis = () => {\n    const bufferLength = analyzerRef.current.frequencyBinCount;\n    const dataArray = new Uint8Array(bufferLength);\n\n    const analyze = () => {\n      if (!analyzerRef.current) return;\n\n      analyzerRef.current.getByteFrequencyData(dataArray);\n\n      // Focus on breathing frequency range (0.1 - 2 Hz)\n      // This translates to lower frequency bins in our FFT\n      const breathingBins = dataArray.slice(1, 20); // Approximate breathing range\n\n      // Calculate amplitude (breath volume)\n      const amplitude =\n        breathingBins.reduce((sum, val) => sum + val, 0) /\n        breathingBins.length /\n        255;\n\n      // Calculate dominant frequency in breathing range\n      const maxBin = breathingBins.reduce(\n        (maxIdx, val, idx) => (val > breathingBins[maxIdx] ? idx : maxIdx),\n        0\n      );\n      const dominantFreq =\n        maxBin *\n        (audioContextRef.current.sampleRate / analyzerRef.current.fftSize);\n\n      // Add to history for pattern analysis\n      const timestamp = Date.now();\n      breathHistoryRef.current.push({\n        amplitude,\n        frequency: dominantFreq,\n        timestamp,\n      });\n\n      // Keep only recent history (last 10 seconds)\n      breathHistoryRef.current = breathHistoryRef.current.filter(\n        (entry) => timestamp - entry.timestamp < 10000\n      );\n\n      // Analyze breathing pattern\n      const pattern = analyzeBreathPattern(breathHistoryRef.current);\n\n      // Determine breath phase\n      const breathPhase = determineBreathPhase(amplitude, pattern);\n\n      // Calculate breath metrics\n      const breathDepth = Math.min(1, amplitude * 2); // Normalize breath depth\n      const breathRhythm = calculateRhythm(breathHistoryRef.current);\n      const coherence = calculateCoherence(breathHistoryRef.current);\n\n      setBreathData({\n        amplitude,\n        frequency: dominantFreq,\n        breathPhase,\n        breathDepth,\n        breathRhythm,\n        coherence,\n        rawData: Array.from(breathingBins),\n      });\n\n      animationFrameRef.current = requestAnimationFrame(analyze);\n    };\n\n    analyze();\n  };\n\n  const determineBreathPhase = (amplitude, pattern) => {\n    const threshold = 0.1;\n    const currentTime = Date.now();\n\n    // Detect phase transitions based on amplitude changes\n    if (amplitude > threshold) {\n      if (\n        pattern.trend === \"increasing\" &&\n        amplitude > pattern.avgAmplitude * 1.2\n      ) {\n        if (lastPhaseRef.current !== \"inhale\") {\n          lastPhaseRef.current = \"inhale\";\n          phaseTimerRef.current = currentTime;\n        }\n        return \"inhale\";\n      } else if (\n        pattern.trend === \"decreasing\" &&\n        amplitude > pattern.avgAmplitude * 0.8\n      ) {\n        if (lastPhaseRef.current !== \"exhale\") {\n          lastPhaseRef.current = \"exhale\";\n          phaseTimerRef.current = currentTime;\n        }\n        return \"exhale\";\n      }\n    } else {\n      // Low amplitude - likely a pause between breaths\n      if (currentTime - phaseTimerRef.current > 500) {\n        // 500ms threshold\n        lastPhaseRef.current = \"pause\";\n        return \"pause\";\n      }\n    }\n\n    return lastPhaseRef.current || \"neutral\";\n  };\n\n  const calculateRhythm = (history) => {\n    if (history.length < 20) return 0;\n\n    // Calculate rhythm consistency over time\n    const intervals = [];\n    for (let i = 1; i < history.length; i++) {\n      intervals.push(history[i].timestamp - history[i - 1].timestamp);\n    }\n\n    const avgInterval =\n      intervals.reduce((sum, val) => sum + val, 0) / intervals.length;\n    const variance =\n      intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) /\n      intervals.length;\n    const stdDev = Math.sqrt(variance);\n\n    // Lower standard deviation means more rhythmic breathing\n    return Math.max(0, 1 - stdDev / avgInterval);\n  };\n\n  const calculateCoherence = (history) => {\n    if (history.length < 30) return 0;\n\n    // Heart Rate Variability-inspired coherence calculation\n    const amplitudes = history.map((entry) => entry.amplitude);\n    const mean =\n      amplitudes.reduce((sum, val) => sum + val, 0) / amplitudes.length;\n\n    // Calculate how smoothly amplitude changes over time\n    let coherenceScore = 0;\n    for (let i = 1; i < amplitudes.length; i++) {\n      const change = Math.abs(amplitudes[i] - amplitudes[i - 1]);\n      coherenceScore += Math.exp(-change * 10); // Reward smooth changes\n    }\n\n    return Math.min(1, coherenceScore / amplitudes.length);\n  };\n\n  const cleanup = () => {\n    if (animationFrameRef.current) {\n      cancelAnimationFrame(animationFrameRef.current);\n    }\n\n    if (sourceRef.current) {\n      sourceRef.current.disconnect();\n    }\n\n    if (audioContextRef.current && audioContextRef.current.state !== \"closed\") {\n      audioContextRef.current.close();\n    }\n  };\n\n  return breathData;\n}\n\nexport default useBreathDetection;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}